name: Deploy Wazuh (Official Kubernetes Manifests)

on:
  workflow_dispatch:
    inputs:
      overlay:
        description: "Overlay to deploy"
        required: true
        default: single
        type: choice
        options:
          - single
          - production
      wazuh_tag:
        description: "wazuh-kubernetes repo tag (e.g., v4.12.0)"
        required: true
        default: v4.12.0

jobs:
  deploy:
    runs-on: [self-hosted, linux, ronin, k8s, control-plane]
    timeout-minutes: 45
    env:
      NS: wazuh
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml
      WAZUH_K8S_TAG: ${{ inputs.wazuh_tag }}
      OVERLAY_CHOICE: ${{ inputs.overlay }}

    steps:
      - name: Checkout (this repo)
        uses: actions/checkout@v4

      - name: Ensure kubectl
        run: |
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -sS https://dl.k8s.io/release/stable.txt)"
            curl -sSLo kubectl "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          fi
          kubectl version --client=true | head -n 1

      - name: Write kubeconfig from secret
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG_B64 }}
        run: |
          test -n "$KUBE_CONFIG_B64" || { echo "::error::Secret KUBE_CONFIG_B64 missing"; exit 1; }
          echo "$KUBE_CONFIG_B64" | base64 -d > "$KUBECONFIG"
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Ensure namespace
        run: |
          kubectl create namespace "$NS" --dry-run=client -o yaml | kubectl apply -f -

      # ---------------- SYSCTL: vm.max_map_count ----------------
      - name: Apply sysctl DaemonSet (vm.max_map_count=262144 on all nodes)
        run: |
          cat > /tmp/wazuh-sysctl-ds.yaml <<'EOF'
          apiVersion: apps/v1
          kind: DaemonSet
          metadata:
            name: wazuh-sysctl
            namespace: kube-system
            labels: { app: wazuh-sysctl }
          spec:
            selector:
              matchLabels: { app: wazuh-sysctl }
            template:
              metadata:
                labels: { app: wazuh-sysctl }
              spec:
                hostPID: true
                tolerations:
                  - operator: "Exists"
                containers:
                  - name: sysctl
                    image: busybox:1.36
                    securityContext: { privileged: true }
                    command: ["/bin/sh","-c"]
                    args:
                      - |
                        set -e
                        echo 262144 > /host-proc/sys/vm/max_map_count
                        mkdir -p /host-etc/sysctl.d
                        echo "vm.max_map_count=262144" > /host-etc/sysctl.d/99-wazuh.conf
                        echo "vm.max_map_count now: $(cat /host-proc/sys/vm/max_map_count)"
                        # keep alive briefly for log inspection
                        sleep 120
                    volumeMounts:
                      - { name: host-proc, mountPath: /host-proc }
                      - { name: host-etc,  mountPath: /host-etc  }
                volumes:
                  - { name: host-proc, hostPath: { path: /proc, type: Directory } }
                  - { name: host-etc,  hostPath: { path: /etc,  type: Directory } }
          EOF
          kubectl apply -f /tmp/wazuh-sysctl-ds.yaml

      - name: Verify sysctl DS
        run: |
          kubectl -n kube-system rollout status ds/wazuh-sysctl --timeout=180s || true
          kubectl -n kube-system get pods -l app=wazuh-sysctl -o wide
          for p in $(kubectl -n kube-system get pods -l app=wazuh-sysctl -o name); do
            echo "# $p"
            kubectl -n kube-system logs "$p" || true
          done

      - name: Cleanup sysctl DS (persistent config remains on nodes)
        run: |
          kubectl -n kube-system delete ds/wazuh-sysctl --ignore-not-found=true
      # ---------------- END SYSCTL ----------------

      - name: Ensure dynamic StorageClass alias 'wazuh-storage'
        run: |
          set -euo pipefail
          if kubectl get sc local-path >/dev/null 2>&1; then
            TARGET_SC="local-path"
          else
            TARGET_SC=$(kubectl get sc -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.provisioner}{"\n"}{end}' \
              | awk '$2!="kubernetes.io/no-provisioner"{print $1; exit}')
          fi
          test -n "${TARGET_SC:-}" || { echo "::error::No dynamic StorageClass found"; exit 1; }
          TARGET_PROV=$(kubectl get sc "$TARGET_SC" -o jsonpath='{.provisioner}')
          echo "Using SC '${TARGET_SC}' (${TARGET_PROV}) for wazuh-storage"

          if kubectl get sc wazuh-storage >/dev/null 2>&1; then
            CUR_PROV=$(kubectl get sc wazuh-storage -o jsonpath='{.provisioner}')
            if [ "$CUR_PROV" != "$TARGET_PROV" ]; then
              kubectl delete sc wazuh-storage
            fi
          fi

          cat <<EOF | kubectl apply -f -
          apiVersion: storage.k8s.io/v1
          kind: StorageClass
          metadata: { name: wazuh-storage }
          provisioner: ${TARGET_PROV}
          reclaimPolicy: Delete
          volumeBindingMode: WaitForFirstConsumer
          allowVolumeExpansion: true
          EOF

          kubectl get sc -o wide

      - name: Fetch official wazuh-kubernetes repo
        run: |
          set -euo pipefail
          rm -rf wazuh-kubernetes
          git clone --depth 1 --branch "$WAZUH_K8S_TAG" https://github.com/wazuh/wazuh-kubernetes.git
          echo "Fetched wazuh-kubernetes@$WAZUH_K8S_TAG"
          ls -la wazuh-kubernetes

      # --------- AUTO-DISCOVER OVERLAY PATH (robust) ----------
      - name: Resolve overlay path (auto-detect layout)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          want_keyword="${OVERLAY_CHOICE}"        # "single" or "production"
          # 1) Collect all dirs that contain Wazuh k8s manifests (dashboard/manager/indexer)
          mapfile -t candidate_dirs < <(
            grep -RIl --include='*.yml' --include='*.yaml' -e 'wazuh-dashboard\|wazuh-manager\|wazuh-indexer' wazuh-kubernetes 2>/dev/null \
              | xargs -r -n1 dirname \
              | sort -u
          )

          if [ ${#candidate_dirs[@]} -eq 0 ]; then
            echo "::error::Could not find any Wazuh Kubernetes manifests in this tag."
            ls -laR wazuh-kubernetes | sed -n '1,200p'
            exit 1
          fi

          # 2) Prefer a directory whose path name hints the chosen overlay
          chosen=""
          for d in "${candidate_dirs[@]}"; do
            base="$(echo "$d" | tr '[:upper:]' '[:lower:]')"
            if [[ "$want_keyword" == "single" && "$base" =~ single ]]; then chosen="$d"; break; fi
            if [[ "$want_keyword" == "production" && "$base" =~ prod ]]; then chosen="$d"; break; fi
          done

          # 3) Fallback: first candidate
          if [ -z "$chosen" ]; then
            chosen="${candidate_dirs[0]}"
          fi

          echo "overlay_path=$chosen" >> "$GITHUB_OUTPUT"
          echo "Resolved overlay path: $chosen"
          # Show a sample of what will be applied
          ls -la "$chosen" | sed -n '1,120p'

      - name: Inject namespace if missing (idempotent)
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.resolve.outputs.overlay_path }}"
          for f in $(find . -type f \( -name '*.yaml' -o -name '*.yml' \)); do
            # only inject if there's a metadata block and no namespace already
            if grep -qE '^kind:' "$f" && grep -qE '^metadata:' "$f" && ! grep -qE '^[[:space:]]*namespace:' "$f"; then
              awk -v ns="$NS" '
                BEGIN{inmeta=0}
                /^metadata:[[:space:]]*$/ {print; inmeta=1; next}
                inmeta==1 && !printed && $0 ~ /^[[:space:]]{2}name:/ {print; print "  namespace: " ns; printed=1; next}
                {print}
              ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
            fi
          done
          echo "Namespace ensured for files in: $PWD"

      - name: Apply official manifests
        run: |
          kubectl apply -f "${{ steps.resolve.outputs.overlay_path }}/"

      - name: Wait for core components
        run: |
          set -euxo pipefail
          kubectl -n "$NS" get pods -o wide || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-manager  --timeout=1200s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-indexer  --timeout=1200s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-dashboard --timeout=1200s || true
          kubectl -n "$NS" get pods -o wide

      - name: Expose Dashboard via NodePort + print URL
        run: |
          set -euo pipefail
          SVC=$(kubectl -n "$NS" get svc -l app=wazuh-dashboard -o jsonpath='{.items[0].metadata.name}' || true)
          if [ -z "$SVC" ]; then
            echo "::warning::Dashboard Service not found; skipping."
            exit 0
          fi
          kubectl -n "$NS" patch svc "$SVC" -p '{"spec":{"type":"NodePort"}}'
          kubectl -n "$NS" patch svc "$SVC" --type='json' -p='[{"op":"remove","path":"/spec/ports/0/nodePort"}]' || true
          PORT=$(kubectl -n "$NS" get svc "$SVC" -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}' | head -n1)
          echo "üåê Wazuh Dashboard: https://${NODE_IP}:${PORT}"
          echo "‚ÑπÔ∏è Accept the self-signed certificate warning on first visit."

      - name: Final status
        run: |
          kubectl -n "$NS" get svc -o wide
          kubectl -n "$NS" get pods -o wide
