name: Deploy Wazuh (Official Kubernetes Manifests)

on:
  workflow_dispatch:
    inputs:
      overlay:
        description: "Overlay to deploy (single or production)"
        required: true
        default: "single"
      wazuh_tag:
        description: "wazuh-kubernetes repo tag (e.g., v4.12.0)"
        required: true
        default: "v4.12.0"
      cleanup_unbound_pvcs:
        description: "Delete UNBOUND PVCs before deploy (true/false)"
        required: true
        default: "true"
      local_forward_port:
        description: "Local port for port-forward"
        required: true
        default: "8444"
      enable_port_forward:
        description: "Start port-forward automatically (true/false)"
        required: true
        default: "true"

jobs:
  deploy:
    runs-on: [self-hosted, linux, ronin, k8s, control-plane]
    timeout-minutes: 180

    env:
      NS: wazuh
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml
      WAZUH_K8S_TAG: ${{ inputs.wazuh_tag }}
      OVERLAY_CHOICE: ${{ inputs.overlay }}
      CLEANUP_UNBOUND_PVCS: ${{ inputs.cleanup_unbound_pvcs }}
      LOCAL_FORWARD_PORT: ${{ inputs.local_forward_port }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure kubectl
        run: |
          set -e
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -sS https://dl.k8s.io/release/stable.txt)"
            curl -sSLo kubectl "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          fi
          kubectl version --client=true | head -n 1

      - name: Install yq (YAML CLI)
        run: |
          set -e
          if ! command -v yq >/dev/null 2>&1; then
            sudo curl -sSL -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
          yq --version

      - name: Write kubeconfig from secret
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG_B64 }}
        run: |
          set -e
          test -n "$KUBE_CONFIG_B64" || { echo "::error::Secret KUBE_CONFIG_B64 missing"; exit 1; }
          echo "$KUBE_CONFIG_B64" | base64 -d > "$KUBECONFIG"
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Ensure namespace
        run: |
          kubectl create namespace "$NS" --dry-run=client -o yaml | kubectl apply -f -

      # ---------- SYSCTL ----------
      - name: Set vm.max_map_count on nodes (DaemonSet)
        run: |
          cat > /tmp/wazuh-sysctl-ds.yaml <<'EOF'
          apiVersion: apps/v1
          kind: DaemonSet
          metadata:
            name: wazuh-sysctl
            namespace: kube-system
            labels: { app: wazuh-sysctl }
          spec:
            selector: { matchLabels: { app: wazuh-sysctl } }
            template:
              metadata: { labels: { app: wazuh-sysctl } }
              spec:
                hostPID: true
                tolerations: [ { operator: "Exists" } ]
                containers:
                  - name: sysctl
                    image: busybox:1.36
                    securityContext: { privileged: true }
                    command: ["/bin/sh","-c"]
                    args:
                      - |
                        set -e
                        echo 262144 > /host-proc/sys/vm/max_map_count
                        mkdir -p /host-etc/sysctl.d
                        echo "vm.max_map_count=262144" > /host-etc/sysctl.d/99-wazuh.conf
                        echo "now: $(cat /host-proc/sys/vm/max_map_count)"
                        sleep 60
                    volumeMounts:
                      - { name: host-proc, mountPath: /host-proc }
                      - { name: host-etc,  mountPath: /host-etc  }
                volumes:
                  - { name: host-proc, hostPath: { path: /proc, type: Directory } }
                  - { name: host-etc,  hostPath: { path: /etc,  type: Directory } }
          EOF
          kubectl apply -f /tmp/wazuh-sysctl-ds.yaml
          kubectl -n kube-system rollout status ds/wazuh-sysctl --timeout=180s || true
          kubectl -n kube-system delete ds/wazuh-sysctl --ignore-not-found=true
      # ---------- END SYSCTL ----------

      - name: Ensure StorageClass alias 'wazuh-storage'
        run: |
          set -e
          if kubectl get sc local-path >/dev/null 2>&1; then
            TARGET_SC="local-path"
          else
            TARGET_SC="$(kubectl get sc -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.provisioner}{"\n"}{end}' | awk '$2!="kubernetes.io/no-provisioner"{print $1; exit}')"
          fi
          test -n "$TARGET_SC" || { echo "::error::No dynamic StorageClass found"; exit 1; }
          TARGET_PROV="$(kubectl get sc "$TARGET_SC" -o jsonpath='{.provisioner}')"
          if kubectl get sc wazuh-storage >/dev/null 2>&1; then
            CUR_PROV="$(kubectl get sc wazuh-storage -o jsonpath='{.provisioner}')"
            if [ "$CUR_PROV" != "$TARGET_PROV" ]; then kubectl delete sc wazuh-storage; fi
          fi
          cat <<EOF | kubectl apply -f -
          apiVersion: storage.k8s.io/v1
          kind: StorageClass
          metadata: { name: wazuh-storage }
          provisioner: ${TARGET_PROV}
          reclaimPolicy: Delete
          volumeBindingMode: WaitForFirstConsumer
          allowVolumeExpansion: true
          EOF

      - name: Fetch official wazuh-kubernetes repo
        run: |
          set -e
          rm -rf wazuh-kubernetes
          git clone --depth 1 --branch "$WAZUH_K8S_TAG" https://github.com/wazuh/wazuh-kubernetes.git
          ls -la wazuh-kubernetes | sed -n '1,120p'

      - name: Resolve overlay path (auto-detect)
        id: resolve
        run: |
          set -e
          WANT="${OVERLAY_CHOICE}"
          CANDS="$(grep -RIl --include='*.yml' --include='*.yaml' -e 'wazuh-dashboard\|wazuh-manager\|wazuh-indexer' wazuh-kubernetes 2>/dev/null | xargs -r -n1 dirname | sort -u)"
          test -n "$CANDS" || { echo "::error::No Wazuh manifests found in repo"; exit 1; }
          PICK=""
          while IFS= read -r d; do
            low="$(echo "$d" | tr '[:upper:]' '[:lower:]')"
            if [ "$WANT" = "single" ] && echo "$low" | grep -q single; then PICK="$d"; break; fi
            if [ "$WANT" = "production" ] && echo "$low" | grep -q prod;  then PICK="$d"; break; fi
          done <<< "$CANDS"
          if [ -z "$PICK" ]; then PICK="$(echo "$CANDS" | head -n1)"; fi
          echo "overlay_path=$PICK" >> "$GITHUB_OUTPUT"
          echo "Resolved: $PICK"

      # ---------- CERTS FOR KUSTOMIZE ----------
      - name: Generate self-signed certs for Kustomize (indexer + dashboard_http)
        run: |
          set -e
          CERTROOT="${{ github.workspace }}/wazuh-kubernetes/wazuh/certs"
          IC="${CERTROOT}/indexer_cluster"
          DH="${CERTROOT}/dashboard_http"
          mkdir -p "$IC" "$DH"

          cat > /tmp/wazuh-openssl.cnf <<'CONF'
          [req]
          default_bits=2048
          prompt=no
          default_md=sha256
          req_extensions = v3_req
          distinguished_name=req_dn
          [req_dn]
          CN=wazuh-local
          [v3_req]
          basicConstraints = CA:FALSE
          keyUsage = digitalSignature, keyEncipherment
          extendedKeyUsage = serverAuth, clientAuth
          subjectAltName = @alt_names
          [alt_names]
          DNS.1 = wazuh-indexer
          DNS.2 = wazuh-indexer.wazuh.svc
          DNS.3 = wazuh-dashboard
          DNS.4 = wazuh-dashboard.wazuh.svc
          DNS.5 = localhost
          IP.1  = 127.0.0.1
          CONF

          openssl genrsa -out "$IC/root-ca-key.pem" 4096
          openssl req -x509 -new -key "$IC/root-ca-key.pem" -sha256 -days 3650 -subj "/CN=Wazuh Root CA" -out "$IC/root-ca.pem"

          sign_ic() {
            local name="$1"
            openssl genrsa -out "$IC/${name}-key.pem" 2048
            openssl req -new -key "$IC/${name}-key.pem" -out "$IC/${name}.csr" -config /tmp/wazuh-openssl.cnf
            openssl x509 -req -in "$IC/${name}.csr" -CA "$IC/root-ca.pem" -CAkey "$IC/root-ca-key.pem" -CAcreateserial -out "$IC/${name}.pem" -days 825 -sha256 -extensions v3_req -extfile /tmp/wazuh-openssl.cnf
            rm -f "$IC/${name}.csr"
          }
          for n in admin dashboard node filebeat; do sign_ic "$n"; done

          openssl genrsa -out "$DH/key.pem" 2048
          openssl req -new -key "$DH/key.pem" -out "$DH/dashboard.csr" -config /tmp/wazuh-openssl.cnf
          openssl x509 -req -in "$DH/dashboard.csr" -CA "$IC/root-ca.pem" -CAkey "$IC/root-ca-key.pem" -CAcreateserial -out "$DH/cert.pem" -days 825 -sha256 -extensions v3_req -extfile /tmp/wazuh-openssl.cnf
          rm -f "$DH/dashboard.csr"

          ls -la "$IC" "$DH"
      # ---------- END CERTS ----------

      - name: Build overlay with Kustomize
        run: |
          set -e
          OVER="${{ steps.resolve.outputs.overlay_path }}"
          kubectl kustomize "$OVER" > /tmp/wazuh-all.yaml
          echo "Built: /tmp/wazuh-all.yaml"
          kubectl -n "$NS" delete deploy wazuh-dashboard --ignore-not-found=true

      - name: Optional cleanup (delete UNBOUND PVCs only)
        run: |
          set -e
          if [ "${CLEANUP_UNBOUND_PVCS}" = "true" ]; then
            UNBOUND="$(kubectl -n "$NS" get pvc --no-headers 2>/dev/null | awk '$2!="Bound"{print $1}')"
            if [ -n "$UNBOUND" ]; then
              for p in $UNBOUND; do kubectl -n "$NS" delete pvc "$p" --ignore-not-found; done
            fi
          fi

      - name: Apply non-StatefulSet resources (filter out StorageClass)
        run: |
          set -e
          yq -o=y e 'select(.kind != "StorageClass" and .kind != "StatefulSet")' /tmp/wazuh-all.yaml > /tmp/wazuh-no-sts-sc.yaml
          if [ -s /tmp/wazuh-no-sts-sc.yaml ]; then
            kubectl -n "$NS" apply -f /tmp/wazuh-no-sts-sc.yaml
          else
            echo "Nothing to apply in non-STS/SC set."
          fi

      - name: Recreate StatefulSets to avoid immutability errors
        run: |
          set -e
          NAMES="$(yq -r 'select(.kind == "StatefulSet" and .metadata.name != null) | .metadata.name' /tmp/wazuh-all.yaml \
                   | sed 's/\r$//' \
                   | grep -E '^[a-z0-9]([-a-z0-9]*[a-z0-9])?$' || true)"
          if [ -n "$NAMES" ]; then
            for n in $NAMES; do
              echo "Deleting STS: $n"
              kubectl -n "$NS" delete statefulset "$n" --ignore-not-found=true
            done
            yq -o=y e 'select(.kind == "StatefulSet")' /tmp/wazuh-all.yaml > /tmp/wazuh-sts.yaml
            kubectl -n "$NS" apply -f /tmp/wazuh-sts.yaml
          else
            echo "No StatefulSets in build."
          fi

      # ---------- ROBUST WAIT + DIAGNOSTICS ----------
      - name: Wait & diagnose core components
        run: |
          set -e
          for sel in "app=wazuh-indexer" "app=wazuh-manager" "app=wazuh-dashboard"; do
            echo "Waiting for: $sel"
            if ! kubectl -n "$NS" wait --for=condition=Ready pod -l "$sel" --timeout=1800s; then
              echo "::warning::Timeout waiting for $sel; dumping diagnostics"
              kubectl -n "$NS" get pods -l "$sel" -o wide || true
              P="$(kubectl -n "$NS" get pods -l "$sel" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | head -n2)"
              for pod in $P; do
                echo "---- describe $pod ----"
                kubectl -n "$NS" describe pod "$pod" || true
                echo "---- logs $pod (last 200 lines, all containers) ----"
                kubectl -n "$NS" logs "$pod" --all-containers --tail=200 || true
              done
            fi
          done
          kubectl -n "$NS" get pods -o wide
      # ---------- END WAIT ----------

      # ---------- PASSWORDLESS AUTHD + AGENT CONFIG ----------
      - name: Enable passwordless authd on ALL managers
        env:
          MANAGER_SELECTOR: app=wazuh-manager
        run: |
          set -euo pipefail
          PODS=$(kubectl -n "$NS" get pods -l "$MANAGER_SELECTOR" -o name)
          test -n "$PODS" || { echo "No manager pods found"; exit 1; }
          for POD in $PODS; do
            echo ">> Patching $POD"
            kubectl -n "$NS" exec "$POD" -- sh -lc '
              set -e
              CONF=/var/ossec/etc/ossec.conf
              cp -f "$CONF" "${CONF}.bak.$(date +%s)"

              if grep -q "<auth>" "$CONF"; then
                if grep -q "<use_password>" "$CONF"; then
                  sed -i "s#<use_password>.*</use_password>#<use_password>no</use_password>#" "$CONF"
                else
                  awk '"'"'/<auth>/{print;ins=1;next} ins && /<\/auth>/{print "    <use_password>no</use_password>"; print; ins=0; next} {print}'"'"' "$CONF" > "$CONF.new" && mv "$CONF.new" "$CONF"
                fi
                grep -q "<ssl_verify_host>" "$CONF" || sed -i "s#</auth>#  <ssl_verify_host>no</ssl_verify_host>\n</auth>#g" "$CONF"
                grep -q "<ssl_auto_negotiate>" "$CONF" || sed -i "s#</auth>#  <ssl_auto_negotiate>yes</ssl_auto_negotiate>\n</auth>#g" "$CONF"
              else
                awk '"'"'/<\/ossec_config>/{print "  <auth>\n    <disabled>no</disabled>\n    <port>1515</port>\n    <use_source_ip>no</use_source_ip>\n    <purge>no</purge>\n    <use_password>no</use_password>\n    <ssl_verify_host>no</ssl_verify_host>\n    <ssl_auto_negotiate>yes</ssl_auto_negotiate>\n  </auth>"; print; next} {print}'"'"' "$CONF" > "$CONF.new" && mv "$CONF.new" "$CONF"
              fi

              if grep -q "<remote>" "$CONF"; then
                sed -i "s#<connection>.*</connection>#<connection>secure</connection>#; s#<protocol>.*</protocol>#<protocol>tcp</protocol>#; s#<port>.*</port>#<port>1514</port>#" "$CONF"
                grep -q "<connection>secure</connection>" "$CONF" || sed -i "s#</remote>#  <connection>secure</connection>\n</remote>#g" "$CONF"
                grep -q "<protocol>tcp</protocol>" "$CONF"      || sed -i "s#</remote>#  <protocol>tcp</protocol>\n</remote>#g" "$CONF"
                grep -q "<port>1514</port>" "$CONF"             || sed -i "s#</remote>#  <port>1514</port>\n</remote>#g" "$CONF"
              else
                awk '"'"'/<\/ossec_config>/{print "  <remote>\n    <connection>secure</connection>\n    <port>1514</port>\n    <protocol>tcp</protocol>\n  </remote>"; print; next} {print}'"'"' "$CONF" > "$CONF.new" && mv "$CONF.new" "$CONF"
              fi

              /var/ossec/bin/wazuh-control restart || true
            '
          done

      - name: Ensure Agent ConfigMap (passwordless + correct services) and restart agents
        run: |
          set -euo pipefail
          cat > /tmp/agent-ossec.conf <<'EOF'
          <ossec_config>
            <client>
              <server>
                <address>wazuh-workers.wazuh.svc.cluster.local</address>
                <port>1514</port>
                <protocol>tcp</protocol>
              </server>
              <enrollment>
                <enabled>yes</enabled>
                <manager_address>wazuh.wazuh.svc.cluster.local</manager_address>
                <port>1515</port>
                <use_password>no</use_password>
                <ssl_verify_host>no</ssl_verify_host>
                <auto_negotiate>no</auto_negotiate>
              </enrollment>
            </client>
          </ossec_config>
          EOF
          kubectl -n "$NS" create configmap wazuh-agent-ossec --from-file=ossec.conf=/tmp/agent-ossec.conf -o yaml --dry-run=client | kubectl apply -f -
          kubectl -n "$NS" rollout restart ds/wazuh-agent
          kubectl -n "$NS" rollout status ds/wazuh-agent --timeout=300s || echo "::warning::Agent DS not fully ready yet"
          kubectl -n "$NS" get pods -l app=wazuh-agent -o wide
      # ---------- END PASSWORDLESS/AUTH ----------

      - name: Expose Dashboard via fixed NodePort
        run: |
          set -e
          DASH_SVC="wazuh-dashboard-nodeport"
          NODEPORT=30443
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${DASH_SVC}
            namespace: ${NS}
          spec:
            type: NodePort
            selector:
              app: wazuh-dashboard
            ports:
            - name: https
              port: 443
              targetPort: 443
              protocol: TCP
              nodePort: ${NODEPORT}
          EOF
          NODE_IP="$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}' | head -n1)"
          echo "WAZUH_NODEPORT_URL=https://${NODE_IP}:${NODEPORT}"

      - name: Quick HTTPS check (NodePort)
        run: |
          set +e
          NODE_IP="$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}' | head -n1)"
          STATUS="$(curl -kIs --connect-timeout 10 "https://${NODE_IP}:30443" | head -n1 || true)"
          echo "Status line from dashboard: ${STATUS:-<no response>}"

      - name: Start Dashboard port-forward (auto)
        if: ${{ inputs.enable_port_forward == 'true' }}
        env:
          PF_BIND: 127.0.0.1   # change to 0.0.0.0 if you want runner-IP access
          PF_PORT: ${{ inputs.local_forward_port }}
        run: |
          set -euo pipefail
          echo "Starting: kubectl -n ${NS} port-forward --address ${PF_BIND} svc/dashboard ${PF_PORT}:443"
          nohup kubectl -n "${NS}" port-forward --address "${PF_BIND}" svc/dashboard "${PF_PORT}:443" > portforward.log 2>&1 &
          PF_PID=$!
          echo "PF PID: ${PF_PID}"
          for i in $(seq 1 30); do
            sleep 2
            if curl -kIs --connect-timeout 2 "https://localhost:${PF_PORT}" >/dev/null 2>&1; then
              break
            fi
          done
          echo "::notice title=Browse Now::Open https://localhost.com:${PF_PORT} (or https://localhost:${PF_PORT}) and accept the self-signed certificate."
          echo "If you are not on the runner host, SSH tunnel to it:"
          echo "  ssh -L ${PF_PORT}:localhost:${PF_PORT} <runner-user>@<runner-ip>"
          timeout 45m tail -f portforward.log || true

      - name: Final status
        run: |
          kubectl -n "$NS" get svc -o wide
          kubectl -n "$NS" get pods -o wide
