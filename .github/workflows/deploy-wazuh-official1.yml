name: Deploy Wazuh (Official Kubernetes Manifests)

on:
  workflow_dispatch:
    inputs:
      overlay:
        description: "Overlay to deploy (single or production)"
        required: true
        default: "single"
      wazuh_tag:
        description: "wazuh-kubernetes repo tag (e.g., v4.12.0)"
        required: true
        default: "v4.12.0"
      cleanup_unbound_pvcs:
        description: "Delete UNBOUND PVCs before deploy (true/false)"
        required: true
        default: "true"
      local_forward_port:
        description: "Local port for port-forward"
        required: true
        default: "8444"

jobs:
  deploy:
    runs-on: [self-hosted, linux, ronin, k8s, control-plane]
    timeout-minutes: 50

    env:
      NS: wazuh
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml
      WAZUH_K8S_TAG: ${{ inputs.wazuh_tag }}
      OVERLAY_CHOICE: ${{ inputs.overlay }}
      CLEANUP_UNBOUND_PVCS: ${{ inputs.cleanup_unbound_pvcs }}
      LOCAL_FORWARD_PORT: ${{ inputs.local_forward_port }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure kubectl
        run: |
          set -e
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -sS https://dl.k8s.io/release/stable.txt)"
            curl -sSLo kubectl "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          kubectl version --client=true | head -n 1

      - name: Write kubeconfig from secret
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG_B64 }}
        run: |
          set -e
          test -n "$KUBE_CONFIG_B64" || { echo "::error::Secret KUBE_CONFIG_B64 missing"; exit 1; }
          echo "$KUBE_CONFIG_B64" | base64 -d > "$KUBECONFIG"
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Ensure namespace
        run: |
          kubectl create namespace "$NS" --dry-run=client -o yaml | kubectl apply -f -

      # ---------- SYSCTL ----------
      - name: Set vm.max_map_count on nodes (DaemonSet)
        run: |
          cat > /tmp/wazuh-sysctl-ds.yaml <<'EOF'
          apiVersion: apps/v1
          kind: DaemonSet
          metadata:
            name: wazuh-sysctl
            namespace: kube-system
            labels:
              app: wazuh-sysctl
          spec:
            selector:
              matchLabels:
                app: wazuh-sysctl
            template:
              metadata:
                labels:
                  app: wazuh-sysctl
              spec:
                hostPID: true
                tolerations:
                  - operator: "Exists"
                containers:
                  - name: sysctl
                    image: busybox:1.36
                    securityContext:
                      privileged: true
                    command: ["/bin/sh","-c"]
                    args:
                      - |
                        set -e
                        echo 262144 > /host-proc/sys/vm/max_map_count
                        mkdir -p /host-etc/sysctl.d
                        echo "vm.max_map_count=262144" > /host-etc/sysctl.d/99-wazuh.conf
                        echo "now: $(cat /host-proc/sys/vm/max_map_count)"
                        sleep 60
                    volumeMounts:
                      - name: host-proc
                        mountPath: /host-proc
                      - name: host-etc
                        mountPath: /host-etc
                volumes:
                  - name: host-proc
                    hostPath:
                      path: /proc
                      type: Directory
                  - name: host-etc
                    hostPath:
                      path: /etc
                      type: Directory
          EOF
          kubectl apply -f /tmp/wazuh-sysctl-ds.yaml
          kubectl -n kube-system rollout status ds/wazuh-sysctl --timeout=180s || true
          kubectl -n kube-system delete ds/wazuh-sysctl --ignore-not-found=true
      # ---------- END SYSCTL ----------

      - name: Ensure StorageClass alias 'wazuh-storage'
        run: |
          set -e
          if kubectl get sc local-path >/dev/null 2>&1; then
            TARGET_SC="local-path"
          else
            TARGET_SC="$(kubectl get sc -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.provisioner}{"\n"}{end}' | awk '$2!="kubernetes.io/no-provisioner"{print $1; exit}')"
          fi
          test -n "$TARGET_SC" || { echo "::error::No dynamic StorageClass found"; exit 1; }
          TARGET_PROV="$(kubectl get sc "$TARGET_SC" -o jsonpath='{.provisioner}')"
          if kubectl get sc wazuh-storage >/dev/null 2>&1; then
            CUR_PROV="$(kubectl get sc wazuh-storage -o jsonpath='{.provisioner}')"
            if [ "$CUR_PROV" != "$TARGET_PROV" ]; then kubectl delete sc wazuh-storage; fi
          fi
          cat <<EOF | kubectl apply -f -
          apiVersion: storage.k8s.io/v1
          kind: StorageClass
          metadata:
            name: wazuh-storage
          provisioner: ${TARGET_PROV}
          reclaimPolicy: Delete
          volumeBindingMode: WaitForFirstConsumer
          allowVolumeExpansion: true
          EOF

      - name: Fetch official wazuh-kubernetes repo
        run: |
          set -e
          rm -rf wazuh-kubernetes
          git clone --depth 1 --branch "$WAZUH_K8S_TAG" https://github.com/wazuh/wazuh-kubernetes.git
          ls -la wazuh-kubernetes | sed -n '1,120p'

      - name: Resolve overlay path (auto-detect)
        id: resolve
        run: |
          set -e
          WANT="${OVERLAY_CHOICE}"
          CANDS="$(grep -RIl --include='*.yml' --include='*.yaml' -e 'wazuh-dashboard\|wazuh-manager\|wazuh-indexer' wazuh-kubernetes 2>/dev/null | xargs -r -n1 dirname | sort -u)"
          test -n "$CANDS" || { echo "::error::No Wazuh manifests found in repo"; exit 1; }
          PICK=""
          while IFS= read -r d; do
            low="$(echo "$d" | tr '[:upper:]' '[:lower:]')"
            if [ "$WANT" = "single" ] && echo "$low" | grep -q single; then PICK="$d"; break; fi
            if [ "$WANT" = "production" ] && echo "$low" | grep -q prod; then PICK="$d"; break; fi
          done <<< "$CANDS"
          if [ -z "$PICK" ]; then PICK="$(echo "$CANDS" | head -n1)"; fi
          echo "overlay_path=$PICK" >> "$GITHUB_OUTPUT"
          echo "Resolved: $PICK"

      - name: Optional cleanup (delete UNBOUND PVCs only)
        run: |
          set -e
          if [ "${CLEANUP_UNBOUND_PVCS}" = "true" ]; then
            UNBOUND="$(kubectl -n "$NS" get pvc --no-headers 2>/dev/null | awk '$2!="Bound"{print $1}')"
            if [ -n "$UNBOUND" ]; then
              for p in $UNBOUND; do kubectl -n "$NS" delete pvc "$p" --ignore-not-found; done
            fi
          fi

      - name: Apply overlay (skip StorageClass, StatefulSet, Kustomization)
        run: |
          set -e
          cd "${{ steps.resolve.outputs.overlay_path }}"
          FILES="$(find . -type f \( -name '*.yaml' -o -name '*.yml' \))"
          APPLY_LIST=""
          for f in $FILES; do
            # Skip known-problematic kinds and kustomize files
            if grep -qi '^[[:space:]]*kind:[[:space:]]*StorageClass' "$f"; then echo "Skip StorageClass: $f"; continue; fi
            if grep -qi '^[[:space:]]*kind:[[:space:]]*StatefulSet'  "$f"; then echo "Defer StatefulSet: $f"; continue; fi
            if grep -qi '^[[:space:]]*kind:[[:space:]]*Kustomization' "$f" || echo "$f" | grep -qi 'kustomization\.ya\?ml$'; then echo "Skip Kustomization: $f"; continue; fi
            APPLY_LIST="$APPLY_LIST $f"
          done
          if [ -n "$APPLY_LIST" ]; then
            for f in $APPLY_LIST; do kubectl apply -f "$f"; done
          else
            echo "No non-STS/non-SC/non-Kustomization manifests to apply."
          fi

      - name: Recreate StatefulSets to avoid immutability errors
        run: |
          set -e
          cd "${{ steps.resolve.outputs.overlay_path }}"
          STS_FILES="$(grep -RIl --include='*.yml' --include='*.yaml' '^[[:space:]]*kind:[[:space:]]*StatefulSet' . || true)"
          if [ -n "$STS_FILES" ]; then
            for f in $STS_FILES; do
              # Extract name safely (fallback to dry-run)
              NAME="$(awk '/^[[:space:]]*metadata:[[:space:]]*$/,/^[^ ]/{if($1=="name:"){print $2; exit}}' "$f")"
              if [ -z "$NAME" ]; then
                NAME="$(kubectl create --dry-run=client -f "$f" -o jsonpath='{.metadata.name}' 2>/dev/null || true)"
              fi
              if [ -n "$NAME" ]; then
                kubectl -n "$NS" delete statefulset "$NAME" --ignore-not-found=true
              fi
              kubectl apply -f "$f"
            done
          else
            echo "No StatefulSets found."
          fi

      - name: Wait for core components
        run: |
          set -e
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-manager  --timeout=1200s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-indexer  --timeout=1200s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-dashboard --timeout=1200s || true
          kubectl -n "$NS" get pods -o wide

      - name: Expose Dashboard via fixed NodePort
        run: |
          set -e
          DASH_SVC="wazuh-dashboard-nodeport"
          NODEPORT=30443
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${DASH_SVC}
            namespace: ${NS}
          spec:
            type: NodePort
            selector:
              app: wazuh-dashboard
            ports:
            - name: https
              port: 443
              targetPort: 443
              protocol: TCP
              nodePort: ${NODEPORT}
          EOF
          NODE_IP="$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}' | head -n1)"
          echo "WAZUH_NODEPORT_URL=https://${NODE_IP}:${NODEPORT}"

      - name: Print port-forward one-liner
        run: |
          echo "Local tunnel (optional):"
          echo "  kubectl -n ${NS} port-forward svc/wazuh-dashboard-nodeport ${LOCAL_FORWARD_PORT}:443"
          echo "Open: https://localhost:${LOCAL_FORWARD_PORT} (accept the self-signed cert)"

      - name: Final status
        run: |
          kubectl -n "$NS" get svc -o wide
          kubectl -n "$NS" get pods -o wide
