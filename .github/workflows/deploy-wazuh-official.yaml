name: Deploy Wazuh (4.12.0, auto on commit)

on:
  push:
    branches: [ "main" ]
    paths:
      - ".github/workflows/**"
      - "wazuh/**"
      - "envs/**"
      - "**/*.yaml"
      - "**/*.yml"
      - "README.md"
  workflow_dispatch: {}

concurrency:
  group: deploy-wazuh
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: self-hosted
    env:
      NS: wazuh
      WAZUH_TAG: v4.12.0
      DASH_PORT: 32563

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Verify KUBE_CONFIG secret exists
        run: |
          if [ -z "${{ secrets.KUBE_CONFIG }}" ]; then
            echo "::error::Missing KUBE_CONFIG secret (Settings → Secrets → Actions)."
            exit 1
          fi

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Install openssl and jq
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y openssl jq

      # --- FIXED kubeconfig writer (handles raw, base64, or \n-escaped) ---
      - name: Write kubeconfig
        env:
          KUBE_CONFIG_SECRET: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.kube"
          tmp="$(mktemp)"
          printf '%s' "${KUBE_CONFIG_SECRET}" > "$tmp"

          out="$HOME/.kube/config"
          if base64 -d "$tmp" >/dev/null 2>&1; then
            base64 -d "$tmp" > "$out"
          elif grep -q '\\n' "$tmp"; then
            # turn literal \n into real newlines
            printf '%b' "$(cat "$tmp")" > "$out"
          else
            cp "$tmp" "$out"
          fi

          # normalise CRLF just in case
          tr -d '\r' <"$out" >"$out.tmp" && mv "$out.tmp" "$out"
          chmod 600 "$out"
          echo "KUBECONFIG=$HOME/.kube/config" >> "$GITHUB_ENV"

          # non-secret sanity check
          head -n 5 "$out" || true
          grep -q '^apiVersion:' "$out" || { echo 'kubeconfig missing apiVersion'; exit 1; }

      - name: Show cluster and nodes
        run: |
          set -euxo pipefail
          echo "Context: $(kubectl config current-context || true)"
          echo "API server: $(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || true)"
          kubectl version --short
          kubectl get nodes -o wide

      - name: Runner breadcrumb on Ronin
        run: |
          set -euxo pipefail
          sudo mkdir -p /opt/actions-runner/job-logs
          echo "$(date -Is) job=${GITHUB_JOB} run=${GITHUB_RUN_ID} sha=${GITHUB_SHA} actor=${GITHUB_ACTOR}" \
            | sudo tee -a /opt/actions-runner/job-logs/wazuh-actions.log

      - name: Clone wazuh-kubernetes v4.12.0
        run: |
          set -euxo pipefail
          rm -rf wazuh-kubernetes
          git clone https://github.com/wazuh/wazuh-kubernetes.git -b "$WAZUH_TAG" --depth=1
          ls -la wazuh-kubernetes

      - name: Generate certs
        working-directory: ./wazuh-kubernetes
        run: |
          set -euxo pipefail
          bash wazuh/certs/indexer_cluster/generate_certs.sh
          bash wazuh/certs/dashboard_http/generate_certs.sh
          echo "Generated cert files (sample):"
          find wazuh/certs -type f \( -name "*.pem" -o -name "*.key" \) | head -n 20

      - name: Dry run build (client-side with kubectl kustomize)
        working-directory: ./wazuh-kubernetes
        run: |
          set -euxo pipefail
          kubectl kustomize envs/local-env | head -n 60

      - name: Ensure wazuh namespace exists
        run: |
          set -euxo pipefail
          kubectl create namespace "$NS" --dry-run=client -o yaml | kubectl apply -f -

      - name: Server dry-run apply (catches RBAC/schema)
        working-directory: ./wazuh-kubernetes
        run: |
          set -euxo pipefail
          kubectl apply -k envs/local-env/ --dry-run=server

      - name: Apply manifests (local-env)
        working-directory: ./wazuh-kubernetes
        run: |
          set -euxo pipefail
          kubectl apply -k envs/local-env/

      - name: Wait for pods to be ready
        run: |
          set -euxo pipefail
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-dashboard --timeout=600s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-indexer --timeout=600s || true
          kubectl -n "$NS" wait --for=condition=Ready pod -l app=wazuh-manager --timeout=600s || true
          kubectl -n "$NS" get pods -o wide || true

      - name: Expose dashboard on NodePort
        env:
          DASH_PORT: ${{ env.DASH_PORT }}
        run: |
          set -euxo pipefail
          SVC=$(kubectl -n "$NS" get svc -l app=wazuh-dashboard -o jsonpath='{.items[0].metadata.name}' || true)
          if [ -z "$SVC" ]; then
            echo "::warning::Dashboard Service not found; skipping patch."
            exit 0
          fi
          cat > /tmp/patch.json <<'EOF'
          {
            "spec": {
              "type": "NodePort",
              "ports": [{
                "name": "https",
                "port": 443,
                "targetPort": 443,
                "protocol": "TCP",
                "nodePort": __NODEPORT__
              }]
            }
          }
          EOF
          sed -i "s/__NODEPORT__/${DASH_PORT}/" /tmp/patch.json
          kubectl -n "$NS" patch svc "$SVC" --type=merge -p "$(cat /tmp/patch.json)"
          kubectl -n "$NS" get svc "$SVC" -o wide
          echo "URL: https://<any-node-ip>:${DASH_PORT}"

      - name: Quick status
        run: |
          set -euxo pipefail
          echo "=== Pods ==="
          kubectl -n "$NS" get pods -o wide || true
          echo "=== Services ==="
          kubectl -n "$NS" get svc -o wide || true
          echo "=== PVCs ==="
          kubectl -n "$NS" get pvc -o wide || true
          echo "=== Deployments/StatefulSets ==="
          kubectl -n "$NS" get statefulsets,deploy -o wide || true

      - name: Collect diagnostics
        if: always()
        run: |
          set -euxo pipefail
          mkdir -p diag
          kubectl -n "$NS" get all -o wide > diag/get-all.txt 2>&1 || true
          kubectl -n "$NS" get events --sort-by=.lastTimestamp > diag/events.txt 2>&1 || true
          kubectl -n "$NS" get pods -o yaml > diag/pods.yaml 2>&1 || true
          kubectl -n "$NS" get pvc -o yaml > diag/pvc.yaml 2>&1 || true
          kubectl get storageclass -o yaml > diag/storageclass.yaml 2>&1 || true
          kubectl -n "$NS" get svc -o yaml > diag/svc.yaml 2>&1 || true
          for pod in $(kubectl -n "$NS" get pods -o name 2>/dev/null); do
            pn=${pod#pod/}
            kubectl -n "$NS" logs "$pod" --all-containers=true --prefix=true > "diag/logs-${pn}.txt" 2>&1 || true
            kubectl -n "$NS" describe "$pod" > "diag/describe-${pn}.txt" 2>&1 || true
          done

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: wazuh-diagnostics-${{ github.run_id }}
          path: diag/**

      - name: Health check and URL hint
        run: |
          set -euxo pipefail
          kubectl -n "$NS" get pods -o wide || true
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}' 2>/dev/null || echo "<node-ip>")
          echo "Wazuh Dashboard URL: https://${NODE_IP}:${DASH_PORT}"
          echo "Accept the self-signed certificate warning."
